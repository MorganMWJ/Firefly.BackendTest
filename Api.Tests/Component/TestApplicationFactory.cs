using Database;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.AspNetCore.TestHost;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;

namespace Api.Tests.Component;

public class TestApplicationFactory : WebApplicationFactory<Program>
{
    private string _databaseConnectionString;

    public TestApplicationFactory(string databaseConnectionString)
    {
        _databaseConnectionString = databaseConnectionString;
    }

    protected override void ConfigureClient(HttpClient client)
    {
        // use to config http client before setting off requests
    }

    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        // use to mock out some services for testing
        builder.ConfigureTestServices(services =>
        {
            // Remove registraion used in Program.cs
            services.RemoveAll<ApiContext>();
            services.RemoveAll<DbContextOptions<ApiContext>>();

            // Connect to SQL Server DB running in Docker container
            services.AddDbContext<ApiContext>(options =>
               options.UseSqlServer(_databaseConnectionString, b => b.MigrationsAssembly("Api"))
               .EnableSensitiveDataLogging());
        });
    }

    /*
     * Note: if running migrations you need to point to the assembly
     * that has access to the the migrations generated by the command:
     *     "dotnet ef migrations add <migrationName>"
     * 
     * Since we run migrations after starting the sql server docker test container
     * in ControllerTestsFixture.cs on line 39 we must set the migrations assembly
     * 
     * This is done above with the code:
     *   options.UseSqlServer(_databaseConnectionString, b => b.MigrationsAssembly("Api"))
     */
}